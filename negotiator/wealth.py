"""Ergodic wealth process utilities."""

from __future__ import annotations

from dataclasses import dataclass, field
from typing import Iterable, List, Sequence, Tuple
import math

import numpy as np

from .config import EconomicConfig, WealthConfig


def _clamp(value: float, minimum: float) -> float:
    return value if value > minimum else minimum


def compute_cashflow(outcome: Tuple[int, int, int], role: str, config: EconomicConfig) -> float:
    """Return the signed cashflow generated by an agreement for a given role."""

    price, quantity, delivery = outcome
    quantity = float(quantity)
    price = float(price)
    delivery = float(delivery)

    if role == "buyer":
        base_value = (
            config.buyer_value_intercept
            + config.buyer_value_quantity_scale * quantity
            - config.buyer_delivery_penalty * delivery
        )
        value = quantity * base_value
        payment = price * quantity
        return value - payment

    revenue = price * quantity
    production_cost = (
        config.seller_cost_intercept
        + config.seller_cost_quantity_scale * quantity
        + config.seller_delivery_cost * delivery
    )
    cost = production_cost * quantity
    return revenue - cost


@dataclass
class WealthManager:
    """Tracks the multiplicative wealth process and associated log returns."""

    role: str
    economic: EconomicConfig
    wealth_cfg: WealthConfig
    wealth: float = field(init=False)
    log_returns: List[float] = field(init=False)
    wealth_history: List[float] = field(init=False)

    def __post_init__(self) -> None:
        self.reset()

    def reset(self) -> None:
        self.wealth = float(self.wealth_cfg.initial_wealth)
        self.log_returns = []
        self.wealth_history = [self.wealth]

    def apply_time_penalty(self) -> float:
        """Apply a per-step time penalty."""

        factor = max(1e-6, 1.0 - self.wealth_cfg.time_penalty)
        prev = _clamp(self.wealth, 1e-6)
        self.wealth *= factor
        log_r = math.log(_clamp(self.wealth, 1e-6)) - math.log(prev)
        self.log_returns.append(log_r)
        self.wealth_history.append(self.wealth)
        log_r += self._ruin_penalty()
        return log_r

    def apply_deal(self, outcome: Tuple[int, int, int]) -> float:
        """Apply the reward from a reached agreement."""

        prev = _clamp(self.wealth, 1e-6)
        cashflow = compute_cashflow(outcome, self.role, self.economic)
        rate = cashflow / max(self.economic.capital_scale, 1e-6)
        factor = max(1e-6, 1.0 + rate)
        self.wealth *= factor
        log_r = math.log(_clamp(self.wealth, 1e-6)) - math.log(prev)
        self.log_returns.append(log_r)
        self.wealth_history.append(self.wealth)
        log_r += self._ruin_penalty()
        return log_r

    def _ruin_penalty(self) -> float:
        if self.wealth < self.wealth_cfg.ruin_threshold:
            self.wealth = max(self.wealth_cfg.ruin_threshold * 0.1, self.wealth)
            self.log_returns.append(self.wealth_cfg.ruin_penalty)
            self.wealth_history.append(self.wealth)
            return self.wealth_cfg.ruin_penalty
        return 0.0

    def time_average_growth(self) -> float:
        return time_average_growth(self.log_returns)

    def wealth_path(self) -> np.ndarray:
        return np.array(self.wealth_history, dtype=np.float64)


def time_average_growth(log_returns: Sequence[float]) -> float:
    if not log_returns:
        return 0.0
    return float(sum(log_returns) / len(log_returns))


def ensemble_average_growth(wealth_paths: Iterable[Sequence[float]]) -> float:
    wealth_paths = [np.asarray(path, dtype=np.float64) for path in wealth_paths]
    if not wealth_paths:
        return 0.0
    min_len = min(len(path) for path in wealth_paths)
    truncated = np.stack([path[:min_len] for path in wealth_paths], axis=0)
    mean_path = truncated.mean(axis=0)
    return float(math.log(mean_path[-1] / mean_path[0]) / (len(mean_path) - 1))
